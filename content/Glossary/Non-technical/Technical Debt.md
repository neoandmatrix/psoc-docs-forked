Careless and lazy implementation in code that creates a series of bottlenecks, issues and failures in future or in the code that is dependent on it. 

Obviously, tech debt is more than language and tool updates. It can be good-faith coding decisions done for an immediate benefit. The sooner you can address your debts, the better. But addressing those debts requires you further dig into the tech debt metaphor and quantify exactly how much debt your engineering team is carrying.

# If you want to address tech debt, quantify it first.

Plenty of successful companies used tech debt to get off the ground, only to pay it off later. For example, [Facebook was originally written in PHP](https://engineering.fb.com/2020/05/08/web/facebook-redesign/). The first implementation worked for what it was, but as they added features, complexity, and scale, they needed to pay off the significant debt that was PHP. It’s worth noting that tech debt doesn’t necessarily mean your original choice was flawed. Writing the site in PHP wasn’t a bad decision at the beginning—this wasn’t a case of bad code biting them later. It was a fine language that they outgrew.

Like financial debts, unpaid technical debts can haunt you as you spend more and more of your time addressing its effects. Bad code begets bad code, and the interest accrues to the principal. You’ll need to pay your debts sometime, but the better case you can make for taking care of them now, the more breathing room you’ll have to write business logic code that you can be proud of